<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM Event Instrumentation Example - IE11 Compatible</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
      }

      .event-area {
        border: 2px solid #ccc;
        padding: 20px;
        margin: 20px 0;
        background-color: #f9f9f9;
        cursor: pointer;
      }

      .event-area:hover {
        background-color: #e9e9e9;
      }

      .button {
        background-color: #007cba;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
      }

      .button:hover {
        background-color: #005a87;
      }

      .log-area {
        border: 1px solid #ddd;
        padding: 10px;
        height: 300px;
        overflow-y: auto;
        background-color: #fff;
        font-family: monospace;
        font-size: 12px;
      }

      .controls {
        margin: 20px 0;
      }

      input[type="text"] {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
      }

      .status.active {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      .status.inactive {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>DOM Event Instrumentation Example</h1>
      <p>
        This example demonstrates OpenTelemetry IE11 compatible DOM event
        instrumentation.
      </p>

      <div class="status" id="status">Status: Initializing...</div>

      <div class="controls">
        <button class="button" onclick="startInstrumentation()">
          Start Instrumentation
        </button>
        <button class="button" onclick="stopInstrumentation()">
          Stop Instrumentation
        </button>
        <button class="button" onclick="clearLogs()">Clear Logs</button>
        <button class="button" onclick="exportLogs()">Export Logs</button>
      </div>

      <div class="controls">
        <label>Filter Events: </label>
        <input
          type="text"
          id="eventFilter"
          placeholder="e.g., click,mouseover"
          onchange="updateEventFilter()"
          value="click,dblclick,keydown,submit"
        />
        <button class="button" onclick="updateEventFilter()">
          Apply Filter
        </button>
      </div>

      <!-- Event Test Areas -->
      <div
        class="event-area"
        onclick="handleAreaClick(event)"
        ondblclick="handleAreaDblClick(event)"
        onmouseover="handleAreaMouseOver(event)"
        onmouseout="handleAreaMouseOut(event)"
      >
        <h3>Click Test Area</h3>
        <p>Click, double-click, or hover over this area to generate events.</p>
      </div>

      <div class="controls">
        <input
          type="text"
          id="textInput"
          placeholder="Type here to generate keydown events"
        />
        <button class="button" onclick="submitForm()">Submit Form</button>
      </div>

      <form onsubmit="handleFormSubmit(event)">
        <input type="text" placeholder="Form input" name="formInput" />
        <input type="submit" value="Submit via Form" class="button" />
      </form>

      <h3>Event Log</h3>
      <div class="log-area" id="logArea"></div>

      <h3>Event Statistics</h3>
      <div id="statistics">
        <p>Total Events: <span id="totalEvents">0</span></p>
        <p>Unique Event Types: <span id="uniqueTypes">0</span></p>
        <p>Most Frequent Event: <span id="mostFrequent">-</span></p>
      </div>
    </div>

    <!-- Include the DOM Event Instrumentation module -->
    <script>
      // Simulate the DOM Event Instrumentation module for IE11
      // In a real implementation, this would be imported from the built module
      var DOMEventInstrumentation = (function () {
        "use strict";

        // Default configuration for IE11 optimization
        var DEFAULT_CONFIG = {
          trackedEvents: [
            "click",
            "dblclick",
            "mousedown",
            "mouseup",
            "mouseover",
            "mouseout",
            "keydown",
            "keyup",
            "keypress",
            "focus",
            "blur",
            "change",
            "submit",
            "load",
            "unload",
            "error",
            "resize",
            "scroll",
          ],
          capturePhase: true,
          bubblePhase: true,
          enableTiming: true,
          maxEventHistory: 1000,
          throttleInterval: 16,
        };

        var HIGH_FREQUENCY_EVENTS = [
          "mousemove",
          "scroll",
          "resize",
          "touchmove",
        ];

        function createInstrumentation(config) {
          config = config || {};
          var cfg = {};

          // IE11 compatible Object.assign
          for (var key in DEFAULT_CONFIG) {
            if (DEFAULT_CONFIG.hasOwnProperty(key)) {
              cfg[key] = DEFAULT_CONFIG[key];
            }
          }
          for (var key in config) {
            if (config.hasOwnProperty(key)) {
              cfg[key] = config[key];
            }
          }

          var handlers = [];
          var eventHistory = [];
          var instrumentedElements = [];
          var throttleTimers = {};
          var isDestroyed = false;

          function getHighResolutionTime() {
            if (typeof performance !== "undefined" && performance.now) {
              return performance.now();
            }
            return Date.now();
          }

          function getElementSelector(element) {
            if (!element || element.nodeType !== 1) {
              return "unknown";
            }

            var tagName = element.tagName.toLowerCase();
            var id = element.id;
            var className = element.className;

            if (id) {
              return tagName + "#" + id;
            }

            if (className && typeof className === "string") {
              var classes = className.split(/\s+/).slice(0, 2).join(".");
              if (classes) {
                return tagName + "." + classes;
              }
            }

            return tagName;
          }

          function shouldThrottle(eventType) {
            return HIGH_FREQUENCY_EVENTS.indexOf(eventType) !== -1;
          }

          function throttleEvent(eventType, callback) {
            var key = eventType;

            if (throttleTimers[key]) {
              return;
            }

            throttleTimers[key] = setTimeout(function () {
              delete throttleTimers[key];
              callback();
            }, cfg.throttleInterval || 16);
          }

          function createEventData(event, phase) {
            var target = event.target;
            var timestamp = getHighResolutionTime();

            return {
              type: event.type,
              target: getElementSelector(target),
              timestamp: timestamp,
              phase: phase,
              bubbled: event.bubbles,
              cancelled: event.defaultPrevented,
              synthetic: !event.isTrusted,
            };
          }

          function addToHistory(eventData) {
            eventHistory.push(eventData);

            if (eventHistory.length > (cfg.maxEventHistory || 1000)) {
              eventHistory.splice(
                0,
                eventHistory.length - (cfg.maxEventHistory || 1000)
              );
            }
          }

          function notifyHandlers(eventData) {
            for (var i = 0; i < handlers.length; i++) {
              try {
                handlers[i](eventData);
              } catch (error) {
                if (typeof console !== "undefined" && console.error) {
                  console.error("DOM Event handler error:", error);
                }
              }
            }
          }

          function processEvent(event, phase) {
            if (isDestroyed) {
              return;
            }

            var eventType = event.type;

            if (
              cfg.trackedEvents &&
              cfg.trackedEvents.indexOf(eventType) === -1
            ) {
              return;
            }

            function doProcess() {
              var eventData = createEventData(event, phase);

              if (cfg.enableTiming) {
                eventData.duration =
                  getHighResolutionTime() - eventData.timestamp;
              }

              addToHistory(eventData);
              notifyHandlers(eventData);
            }

            if (shouldThrottle(eventType)) {
              throttleEvent(eventType, doProcess);
            } else {
              doProcess();
            }
          }

          return {
            addHandler: function (handler) {
              if (isDestroyed || handlers.indexOf(handler) !== -1) {
                return;
              }
              handlers.push(handler);
            },

            removeHandler: function (handler) {
              var index = handlers.indexOf(handler);
              if (index !== -1) {
                handlers.splice(index, 1);
              }
            },

            getEventHistory: function () {
              return eventHistory.slice();
            },

            clearHistory: function () {
              eventHistory = [];
            },

            updateConfig: function (newConfig) {
              for (var key in newConfig) {
                if (newConfig.hasOwnProperty(key)) {
                  cfg[key] = newConfig[key];
                }
              }
            },

            destroy: function () {
              if (isDestroyed) {
                return;
              }

              isDestroyed = true;

              for (var key in throttleTimers) {
                if (throttleTimers.hasOwnProperty(key)) {
                  clearTimeout(throttleTimers[key]);
                }
              }
              throttleTimers = {};

              handlers = [];
              eventHistory = [];
            },

            // Simplified instrumentation for demo
            processEvent: processEvent,
          };
        }

        return {
          createInstrumentation: createInstrumentation,
        };
      })();

      // Application code
      var instrumentation = null;
      var isInstrumentationActive = false;

      function updateStatus(message, isActive) {
        var statusEl = document.getElementById("status");
        statusEl.textContent = "Status: " + message;
        statusEl.className = "status " + (isActive ? "active" : "inactive");
      }

      function logEvent(eventData) {
        var logArea = document.getElementById("logArea");
        var timestamp = new Date(Date.now()).toLocaleTimeString();
        var logEntry =
          "[" +
          timestamp +
          "] " +
          eventData.type +
          " on " +
          eventData.target +
          " (" +
          eventData.phase +
          ")" +
          (eventData.duration
            ? " - " + eventData.duration.toFixed(2) + "ms"
            : "");

        logArea.innerHTML += logEntry + "\n";
        logArea.scrollTop = logArea.scrollHeight;

        updateStatistics();
      }

      function updateStatistics() {
        if (!instrumentation) return;

        var history = instrumentation.getEventHistory();
        var eventTypes = {};

        for (var i = 0; i < history.length; i++) {
          var type = history[i].type;
          eventTypes[type] = (eventTypes[type] || 0) + 1;
        }

        var mostFrequent = "";
        var maxCount = 0;
        for (var type in eventTypes) {
          if (eventTypes.hasOwnProperty(type) && eventTypes[type] > maxCount) {
            mostFrequent = type;
            maxCount = eventTypes[type];
          }
        }

        document.getElementById("totalEvents").textContent = history.length;
        document.getElementById("uniqueTypes").textContent =
          Object.keys(eventTypes).length;
        document.getElementById("mostFrequent").textContent =
          mostFrequent || "-";
      }

      function startInstrumentation() {
        if (isInstrumentationActive) {
          return;
        }

        instrumentation = DOMEventInstrumentation.createInstrumentation({
          trackedEvents: getFilteredEvents(),
          enableTiming: true,
        });

        instrumentation.addHandler(logEvent);

        // Hook into existing event handlers for demo
        var originalHandlers = {};

        function instrumentEventHandler(element, eventType) {
          var originalHandler = element["on" + eventType];
          originalHandlers[eventType] = originalHandler;

          element["on" + eventType] = function (event) {
            instrumentation.processEvent(event, "bubbling");
            if (originalHandler) {
              return originalHandler.call(this, event);
            }
          };
        }

        // Instrument common events
        var eventTypes = [
          "click",
          "dblclick",
          "mouseover",
          "mouseout",
          "keydown",
          "submit",
        ];
        var elements = document.querySelectorAll(
          "[onclick], [ondblclick], [onmouseover], [onmouseout], [onkeydown], [onsubmit]"
        );

        for (var i = 0; i < elements.length; i++) {
          for (var j = 0; j < eventTypes.length; j++) {
            if (elements[i]["on" + eventTypes[j]]) {
              instrumentEventHandler(elements[i], eventTypes[j]);
            }
          }
        }

        // Instrument input field
        var textInput = document.getElementById("textInput");
        textInput.onkeydown = function (event) {
          instrumentation.processEvent(event, "bubbling");
        };

        isInstrumentationActive = true;
        updateStatus("Active - Tracking events", true);
      }

      function stopInstrumentation() {
        if (!isInstrumentationActive) {
          return;
        }

        if (instrumentation) {
          instrumentation.destroy();
          instrumentation = null;
        }

        isInstrumentationActive = false;
        updateStatus("Inactive", false);
      }

      function getFilteredEvents() {
        var filterInput = document.getElementById("eventFilter");
        var filterValue = filterInput.value.trim();

        if (!filterValue) {
          return ["click", "dblclick", "keydown", "submit"];
        }

        return filterValue.split(",").map(function (event) {
          return event.trim();
        });
      }

      function updateEventFilter() {
        if (instrumentation) {
          instrumentation.updateConfig({
            trackedEvents: getFilteredEvents(),
          });
          updateStatus("Active - Updated event filter", true);
        }
      }

      function clearLogs() {
        document.getElementById("logArea").innerHTML = "";
        if (instrumentation) {
          instrumentation.clearHistory();
        }
        updateStatistics();
      }

      function exportLogs() {
        if (!instrumentation) {
          alert("No instrumentation data available");
          return;
        }

        var history = instrumentation.getEventHistory();
        var csvContent = "Timestamp,Type,Target,Phase,Duration\n";

        for (var i = 0; i < history.length; i++) {
          var event = history[i];
          csvContent +=
            event.timestamp +
            "," +
            event.type +
            "," +
            event.target +
            "," +
            event.phase +
            "," +
            (event.duration || "") +
            "\n";
        }

        var blob = new Blob([csvContent], { type: "text/csv" });
        var url = URL.createObjectURL(blob);
        var a = document.createElement("a");
        a.href = url;
        a.download =
          "dom-events-" + new Date().toISOString().slice(0, 10) + ".csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Event handlers for testing
      function handleAreaClick(event) {
        console.log("Area clicked:", event);
      }

      function handleAreaDblClick(event) {
        console.log("Area double-clicked:", event);
      }

      function handleAreaMouseOver(event) {
        console.log("Mouse over area:", event);
      }

      function handleAreaMouseOut(event) {
        console.log("Mouse out of area:", event);
      }

      function submitForm() {
        alert("Form submitted via button!");
      }

      function handleFormSubmit(event) {
        event.preventDefault();
        alert("Form submitted via form element!");
      }

      // Initialize
      window.onload = function () {
        updateStatus('Ready - Click "Start Instrumentation" to begin', false);

        // Auto-start for demo
        setTimeout(function () {
          startInstrumentation();
        }, 1000);
      };
    </script>
  </body>
</html>
